"""Caller profile management for OpenMemory integration.

This module provides functions for:
- Retrieving user profiles from OpenMemory
- Getting user summaries via the OpenMemory API
- Building dynamic variables for ElevenLabs response
- Generating personalized conversation overrides

All operations use the phone number as the userId for multi-tenant isolation.
"""

import logging
from typing import Any, Optional

import requests

from app.config import settings
from app.memory.client import get_openmemory_client, OpenMemoryConnectionError
from app.models.responses import (
    DynamicVariables,
    ConversationConfigOverride,
    AgentConfig,
    ProfileData,
)

logger = logging.getLogger(__name__)


def get_user_profile(phone_number: str) -> Optional[dict[str, Any]]:
    """Query OpenMemory for user profile data.

    Retrieves stored memories for a user to build their profile.

    Args:
        phone_number: The user's phone number in E.164 format (e.g., +16129782029).

    Returns:
        A dictionary containing user profile data, or None if no profile exists.
        Structure:
        {
            "name": str | None,
            "summary": str | None,
            "memories": list[dict],
            "memory_count": int
        }
    """
    try:
        client = get_openmemory_client()

        # Query memories with userId filter to get user-specific data
        results = client.query(
            query="user profile information preferences name",
            k=20,
            filters={"userId": phone_number}
        )

        if not results or not results.get("results"):
            logger.info(f"No profile found for user {phone_number}")
            return None

        memories = results.get("results", [])

        # Extract name from memories if available
        name = _extract_name_from_memories(memories)

        # Build summary from memories
        summary = _build_summary_from_memories(memories)

        return {
            "name": name,
            "summary": summary,
            "memories": memories,
            "memory_count": len(memories),
            "phone_number": phone_number
        }

    except OpenMemoryConnectionError as e:
        logger.error(f"Failed to connect to OpenMemory: {e}")
        return None
    except Exception as e:
        logger.error(f"Error retrieving user profile for {phone_number}: {e}")
        return None


def get_user_summary(phone_number: str) -> Optional[dict[str, Any]]:
    """Retrieve user summary from OpenMemory API.

    Calls the /users/{userId}/summary endpoint to get a comprehensive
    user summary generated by OpenMemory.

    Args:
        phone_number: The user's phone number in E.164 format.

    Returns:
        A dictionary containing the user summary, or None if unavailable.
        Structure:
        {
            "userId": str,
            "name": str | None,
            "summary": str | None,
            "memoryCount": int
        }
    """
    try:
        openmemory_url = settings.openmemory_url
        api_key = settings.OPENMEMORY_KEY

        headers = {
            "Content-Type": "application/json"
        }
        if api_key:
            headers["Authorization"] = f"Bearer {api_key}"

        # URL encode the phone number for the path
        encoded_user_id = requests.utils.quote(phone_number, safe="")
        url = f"{openmemory_url}/users/{encoded_user_id}/summary"

        response = requests.get(url, headers=headers, timeout=10)

        if response.status_code == 404:
            logger.info(f"No summary found for user {phone_number}")
            return None

        response.raise_for_status()
        return response.json()

    except requests.exceptions.RequestException as e:
        logger.error(f"Error fetching user summary for {phone_number}: {e}")
        return None
    except Exception as e:
        logger.error(f"Unexpected error fetching user summary: {e}")
        return None


def build_dynamic_variables(profile: Optional[dict[str, Any]]) -> DynamicVariables:
    """Format profile data for ElevenLabs response.

    Converts OpenMemory profile data into the DynamicVariables format
    expected by ElevenLabs for conversation personalization.

    Args:
        profile: User profile data from get_user_profile() or None for new callers.

    Returns:
        DynamicVariables object with user_name, user_profile_summary, last_call_summary.
        Returns empty/None values for new callers.
    """
    if profile is None:
        return DynamicVariables(
            user_name=None,
            user_profile_summary=None,
            last_call_summary=None
        )

    return DynamicVariables(
        user_name=profile.get("name"),
        user_profile_summary=profile.get("summary"),
        last_call_summary=_get_last_call_summary(profile.get("memories", []))
    )


def build_conversation_override(
    profile: Optional[dict[str, Any]]
) -> Optional[ConversationConfigOverride]:
    """Generate personalized firstMessage for ElevenLabs.

    Creates a conversation configuration override with a personalized
    greeting for returning callers.

    Args:
        profile: User profile data from get_user_profile() or None for new callers.

    Returns:
        ConversationConfigOverride with personalized firstMessage for returning callers,
        or None for new callers (to use ElevenLabs defaults).
    """
    if profile is None:
        # New caller - return None to use ElevenLabs defaults
        return None

    name = profile.get("name")

    if name:
        first_message = f"Welcome back, {name}! How can I help you today?"
    else:
        first_message = "Welcome back! How can I help you today?"

    return ConversationConfigOverride(
        agent=AgentConfig(first_message=first_message)
    )


def build_profile_data(profile: Optional[dict[str, Any]]) -> Optional[ProfileData]:
    """Build ProfileData response model from profile dictionary.

    Args:
        profile: User profile data from get_user_profile() or None.

    Returns:
        ProfileData object or None for new callers.
    """
    if profile is None:
        return None

    return ProfileData(
        name=profile.get("name"),
        summary=profile.get("summary"),
        phone_number=profile.get("phone_number")
    )


def _extract_name_from_memories(memories: list[dict[str, Any]]) -> Optional[str]:
    """Extract user name from memories.

    Searches through memories for content that indicates the user's name.

    Args:
        memories: List of memory objects from OpenMemory.

    Returns:
        The user's name if found, or None.
    """
    name_keywords = ["name is", "my name is", "called", "i'm", "i am"]

    for memory in memories:
        content = memory.get("content", "").lower()
        for keyword in name_keywords:
            if keyword in content:
                # Try to extract the name after the keyword
                idx = content.find(keyword)
                after_keyword = content[idx + len(keyword):].strip()
                # Get the first word (likely the name)
                words = after_keyword.split()
                if words:
                    # Capitalize the name properly
                    name = words[0].strip(".,!?").capitalize()
                    if len(name) > 1:  # Valid name
                        return name

    # Check for explicit name in metadata
    for memory in memories:
        metadata = memory.get("metadata", {})
        if isinstance(metadata, dict):
            if "name" in metadata:
                return metadata["name"]
            if "first_name" in metadata:
                return metadata["first_name"]

    return None


def _build_summary_from_memories(memories: list[dict[str, Any]]) -> Optional[str]:
    """Build a summary from user memories.

    Creates a concise summary based on the stored memories.

    Args:
        memories: List of memory objects from OpenMemory.

    Returns:
        A summary string or None if no meaningful summary can be built.
    """
    if not memories:
        return None

    # Get the most relevant memories (highest salience)
    sorted_memories = sorted(
        memories,
        key=lambda m: m.get("salience", 0.5),
        reverse=True
    )[:3]

    # Build summary from top memories
    summary_parts = []
    for memory in sorted_memories:
        content = memory.get("content", "")
        if content and len(content) < 200:  # Reasonable length
            summary_parts.append(content)

    if summary_parts:
        return " ".join(summary_parts)

    return None


def _get_last_call_summary(memories: list[dict[str, Any]]) -> Optional[str]:
    """Get summary of the last call from memories.

    Args:
        memories: List of memory objects from OpenMemory.

    Returns:
        A summary of the last call or None.
    """
    if not memories:
        return None

    # Sort by timestamp if available, get the most recent
    episodic_memories = [
        m for m in memories
        if m.get("sector") == "episodic"
    ]

    if not episodic_memories:
        return None

    # Get the most recent episodic memory as last call context
    recent = episodic_memories[0]
    content = recent.get("content", "")

    if content:
        return f"Previous conversation: {content[:150]}..."

    return None
